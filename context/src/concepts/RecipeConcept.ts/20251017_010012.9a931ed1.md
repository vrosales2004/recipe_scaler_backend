---
timestamp: 'Fri Oct 17 2025 01:00:12 GMT-0400 (Eastern Daylight Time)'
content_id: 9a931ed1df34a19dc20f64425af9e658397431810b9da96efbe37540756b6bd2
---

# file: src/concepts/RecipeConcept.ts

```typescript
import { Collection, Db } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";

// Collection prefix to ensure namespace separation in MongoDB
const PREFIX = "Recipe" + ".";

// Generic type for the external entity that authors recipes
type Author = ID;
// Internal ID type for a recipe within this concept
type Recipe = ID;

/**
 * @typedef IngredientData
 * Represents a single ingredient within a recipe.
 * This is treated as a plain data structure, not a separate concept,
 * as it doesn't have independent user-facing functionality.
 */
interface IngredientData {
  name: string;
  quantity: number;
  unit: string;
  scalingContext?: string; // e.g., "to taste", "optional", for LLM guidance
}

/**
 * @interface RecipeDoc
 * Represents the structure of a recipe document stored in MongoDB.
 * Corresponds to "A set of Recipes" in the concept state.
 */
interface RecipeDoc {
  _id: Recipe; // MongoDB's primary key for the recipe
  author: Author;
  name: string;
  originalServings: number; // e.g., "serves 4"
  ingredients: IngredientData[];
  cookingMethods: string[]; // e.g., ["bake", "fry", "boil"]
}

/**
 * @concept Recipe
 * @purpose stores an original recipe
 *
 * @principle recipe manually inputted or uploaded with original ingredients and number of people
 *            stores recipes to be accessed by scaler or tipsPage
 */
export default class RecipeConcept {
  // MongoDB collection for storing recipe documents
  recipes: Collection<RecipeDoc>;

  constructor(private readonly db: Db) {
    // Initialize the 'recipes' collection with the defined document interface
    this.recipes = this.db.collection<RecipeDoc>(PREFIX + "recipes");
  }

  /**
   * Action: Creates a new recipe record.
   *
   * @param {Object} params - The parameters for adding a recipe.
   * @param {Author} params.author - The ID of the author creating the recipe.
   * @param {string} params.name - The name of the recipe.
   * @param {number} params.originalServings - The original number of servings the recipe yields.
   * @param {IngredientData[]} params.ingredients - A list of ingredients for the recipe.
   * @param {string[]} params.cookingMethods - A list of cooking methods/steps.
   * @returns {Promise<{recipe: Recipe} | {error: string}>} The ID of the newly created recipe on success, or an error message.
   *
   * @requires originalServings must be greater than 0 and an integer.
   * @requires ingredients must not be empty.
   * @requires name is unique for the given author.
   * @effects A new recipe document is inserted into the 'recipes' collection.
   */
  async addRecipe(
    { author, name, originalServings, ingredients, cookingMethods }: {
      author: Author;
      name: string;
      originalServings: number;
      ingredients: IngredientData[];
      cookingMethods: string[];
    },
  ): Promise<{ recipe: Recipe } | { error: string }> {
    // Precondition: originalServings must be greater than 0
    if (originalServings <= 0) {
      return { error: "originalServings must be greater than 0." };
    }
    // Precondition: originalServings must be an integer
    if (!Number.isInteger(originalServings)) {
      return { error: "originalServings must be an integer." };
    }
    // Precondition: ingredients list must not be empty
    if (ingredients.length === 0) {
      return { error: "Recipe must have at least one ingredient." };
    }

    // Precondition: Check for unique name per author
    const existingRecipe = await this.recipes.findOne({ author, name });
    if (existingRecipe) {
      return {
        error: `A recipe named '${name}' already exists for this author.`,
      };
    }

    // Effect: Create a new recipe document
    const recipeId = freshID() as Recipe; // Generate a fresh ID for the new recipe
    await this.recipes.insertOne({
      _id: recipeId,
      author,
      name,
      originalServings,
      ingredients,
      cookingMethods,
    });

    return { recipe: recipeId }; // Return the ID of the new recipe
  }

  /**
   * Action: Removes an existing recipe record.
   *
   * @param {Object} params - The parameters for removing a recipe.
   * @param {Recipe} params.recipeId - The ID of the recipe to remove.
   * @returns {Promise<Empty | {error: string}>} An empty object on success, or an error message.
   *
   * @requires The recipe with recipeId must exist.
   * @effects The specified recipe document is deleted from the 'recipes' collection.
   */
  async removeRecipe(
    { recipeId }: { recipeId: Recipe },
  ): Promise<Empty | { error: string }> {
    // Precondition: The recipe with recipeId must exist (implied by checking deletion count)
    const result = await this.recipes.deleteOne({ _id: recipeId });
    if (result.deletedCount === 0) {
      return { error: `Recipe with ID ${recipeId} not found.` };
    }

    return {}; // Success
  }

  // --- Queries (start with an underscore '_') ---

  /**
   * Query: Retrieves a single recipe by its ID.
   *
   * @param {Object} params - The query parameters.
   * @param {Recipe} params.recipeId - The ID of the recipe to retrieve.
   * @returns {Promise<RecipeDoc | null>} The recipe document if found, otherwise null.
   */
  async _getRecipeById(
    { recipeId }: { recipeId: Recipe },
  ): Promise<RecipeDoc | null> {
    return await this.recipes.findOne({ _id: recipeId });
  }

  /**
   * Query: Retrieves all recipes for a given author.
   *
   * @param {Object} params - The query parameters.
   * @param {Author} params.author - The ID of the author whose recipes to retrieve.
   * @returns {Promise<RecipeDoc[]>} An array of recipe documents.
   */
  async _getRecipesByAuthor(
    { author }: { author: Author },
  ): Promise<RecipeDoc[]> {
    return await this.recipes.find({ author }).toArray();
  }

  /**
   * Query: Retrieves a recipe by its name and author.
   *
   * @param {Object} params - The query parameters.
   * @param {string} params.recipeName - The name of the recipe to search for.
   * @param {Author} params.author - The ID of the author of the recipe.
   * @returns {Promise<RecipeDoc | null>} The recipe document matching the name and author, or null if not found.
   */
  async _getRecipeByName(
    { recipeName, author }: { recipeName: string; author: Author },
  ): Promise<RecipeDoc | null> {
    return await this.recipes.findOne({
      name: recipeName,
      author,
    });
  }
}

```
